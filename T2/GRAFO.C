/***************************************************************************
*  $MCI Módulo de implementação: Módulo grafo dirigido
*
*  Arquivo gerado:              GRAFO.C
*  Letras identificadoras:      GRA
*
*  Projeto: T2 INF1301 2013.2
*  Autores: gb - Guilherme Berger
*           fl - Felipe Luiz
*           jv - João Vicente
*
***************************************************************************/

#include <malloc.h>
#include <string.h>

#define GRAFO_OWN
#include "GRAFO.H"
#undef GRAFO_OWN

/***********************************************************************
*
*  $TC Tipo de dados: GRA Descritor da célula do grafo
*
*  $ED Descrição do tipo
*     Descreve a organização da célula
*
***********************************************************************/

   typedef struct tagVerticeGrafo {
	   LIS_tppLista pListaAnt;
	   LIS_tppLista pListaSuc;
	   char id;
	   void * pValor;
   } tpVerticeGrafo ;

   typedef tpVerticeGrafo * tppVerticeGrafo;

/***********************************************************************
*
*  $TC Tipo de dados: GRA Descritor da cabeça de um grafo
*
*
*  $ED Descrição do tipo
*     A cabeça da grafo é o ponto de acesso para uma determinada grafo.
*     Por intermédio da referência para a célula corrente pode-se navegar
*     pela grafo.
*
***********************************************************************/

   typedef struct GRA_tagGrafo {
	   LIS_tppLista pListaOrigens;
	   LIS_tppLista pListaVertices;
	   tppVerticeGrafo pVerticeCorrente;
	   void ( * ExcluirValor ) ( void * pValor ) ;
   } GRA_tpGrafo ;

/***********************************************************************
*
*  $TC Tipo de dados: GRA Descritor da aresta de um grafo
*
*
*  $ED Descrição do tipo
*     A aresta do grafo é referenciada no valor do elemento da lista
*     de sucessores de um vértice.
*
***********************************************************************/

   typedef struct GRA_tagAresta {
	   char idAresta[10];
	   tppVerticeGrafo pVerticeApontado;
   } GRA_tpAresta ;



/***** Código das funções encapuladas no módulo *****/

   // Dada uma lista e um valor, insere-o no final
    static GRA_tpCondRet InserirFinalLista(LIS_tppLista pLista , void* pValor){
	   LIS_tpCondRet cond;

	   LIS_IrFinalLista(pLista);
	   cond = LIS_InserirElementoApos(pLista, pValor);

	   if (cond != LIS_CondRetOK){
		   return GRA_CondRetFaltouMemoria;
	   }
	   return GRA_CondRetOK;
   }

   //
   static void DestruirConteudoListaDeAresta (void * pAresta) {
	   free(pAresta);
   }

   // Encapsula verificações de memória
   static tppVerticeGrafo CriarVerticeGrafo (void){
	   tppVerticeGrafo pVertice = NULL;
	   
	   pVertice = (tppVerticeGrafo) malloc(sizeof(tpVerticeGrafo));
	   if (pVertice == NULL){
		   return NULL;
	   }

	   pVertice->pValor = NULL;
	   
	   pVertice->pListaAnt = LIS_CriarLista( NULL ) ;
	   if (pVertice->pListaAnt == NULL){
		   free(pVertice);
		   return NULL;
	   }

	   pVertice->pListaSuc = LIS_CriarLista( DestruirConteudoListaDeAresta ) ;
	   if (pVertice->pListaSuc == NULL){
		   LIS_DestruirLista(pVertice->pListaAnt);
		   free(pVertice);
		   return NULL;
	   }

	   return pVertice;
   }
   
   // Adiciona o vértice do grafo à lista de vértices
   static GRA_tpCondRet AdicionarVertice ( GRA_tppGrafo pGrafo, tppVerticeGrafo pVertice ){
	   return InserirFinalLista(pGrafo->pListaVertices, pVertice);
   }

   static tpVerticeGrafo * PesquisaVertice( LIS_tppLista pLista, char idVertice ) {
	   tpVerticeGrafo * pVerticeGrafo;
	   LIS_IrInicioLista( pLista );

	   do {
		   pVerticeGrafo = (tpVerticeGrafo *) LIS_ObterValor( pLista );
		   if( pVerticeGrafo != NULL && pVerticeGrafo->id == idVertice )
			   return pVerticeGrafo;

	   } while ( LIS_AvancarElementoCorrente( pLista, 1 ) != LIS_CondRetFimLista );

	   return NULL;
   }

   static tpVerticeGrafo * PesquisaVerticeNaListaDeAresta( LIS_tppLista pLista, char idVertice ) {
	   GRA_tpAresta * pAresta;
	   LIS_IrInicioLista( pLista );

	   do {
		   pAresta = (GRA_tpAresta *) LIS_ObterValor( pLista );
		   if( pAresta != NULL && pAresta->pVerticeApontado->id == idVertice )
			   return pAresta->pVerticeApontado;

	   } while ( LIS_AvancarElementoCorrente( pLista, 1 ) != LIS_CondRetFimLista );

	   return NULL;
   }

   // Remove o vértice do grafo da lista de vértices
   static void RemoverVertice ( tppVerticeGrafo pVertice ){
	   tpVerticeGrafo * pVerticeSuc;
	   GRA_tpAresta * pAresta;

	   //Remover arestas sucessoras
	   LIS_IrInicioLista( pVertice->pListaSuc );
	   
	   do {
		   pAresta = (GRA_tpAresta *) LIS_ObterValor( pVertice->pListaSuc );
		   if( pAresta != NULL ) {
			   LIS_ProcurarValor( pAresta->pVerticeApontado->pListaAnt, pVertice );
			   LIS_ExcluirElemento( pAresta->pVerticeApontado->pListaAnt );
		   }

	   } while ( LIS_AvancarElementoCorrente( pVertice->pListaSuc, 1 ) != LIS_CondRetFimLista );

	   //Remover arestas antecessoras
	   LIS_IrInicioLista( pVertice->pListaAnt );
	   
	   do {
		   pVerticeSuc = (tpVerticeGrafo *) LIS_ObterValor( pVertice->pListaAnt );
		   if( pVerticeSuc != NULL ) {
			   PesquisaVerticeNaListaDeAresta( pVerticeSuc->pListaSuc, pVertice->id );
			   LIS_ExcluirElemento( pVerticeSuc->pListaSuc );
		   }

	   } while ( LIS_AvancarElementoCorrente( pVerticeSuc->pListaSuc, 1 ) != LIS_CondRetFimLista );

   }

   static GRA_tpCondRet AdicionarAresta( GRA_tppGrafo pGrafo, tppVerticeGrafo pVerticeOrigem, tppVerticeGrafo pVerticeDestino, char * idAresta) {
	   LIS_tpCondRet CondRetLis;
	   GRA_tpAresta * pAresta;
	   pAresta = (GRA_tpAresta *)malloc(sizeof(GRA_tpAresta));
	   if(pAresta == NULL) {
		   return GRA_CondRetFaltouMemoria;
	   }

	   strcpy(pAresta->idAresta, idAresta);
	   pAresta->pVerticeApontado = pVerticeDestino;

	   LIS_IrFinalLista(pVerticeOrigem->pListaSuc);
	   CondRetLis = LIS_InserirElementoApos(pVerticeOrigem->pListaSuc, (void *) pAresta);
	   if(CondRetLis == LIS_CondRetFaltouMemoria) {
		   return GRA_CondRetFaltouMemoria;
	   }

	   LIS_IrFinalLista(pVerticeDestino->pListaAnt);
	   CondRetLis = LIS_InserirElementoApos(pVerticeDestino->pListaAnt, (void *) pVerticeOrigem);
	   if(CondRetLis == LIS_CondRetFaltouMemoria) {
		   return GRA_CondRetFaltouMemoria;
	   }

	   return GRA_CondRetOK;
   }

/*****  Código das funções exportadas pelo módulo  *****/

/***********************************************************************
*
*  $FC Função: GRA Criar grafo
*
***********************************************************************/

   GRA_tpCondRet GRA_CriarGrafo( GRA_tppGrafo * ppGrafo, void ( * ExcluirValor ) ( void * pDado ) ) {
	   GRA_tppGrafo pGrafo = NULL;
	   
	   pGrafo = (GRA_tppGrafo) malloc(sizeof(GRA_tpGrafo));
	   if (pGrafo == NULL){
		   return GRA_CondRetFaltouMemoria;
	   }

	   pGrafo->pVerticeCorrente = NULL;
	   
	   pGrafo->pListaOrigens = LIS_CriarLista( NULL ) ;
	   if (pGrafo->pListaOrigens == NULL){
		   free(pGrafo);
		   return GRA_CondRetFaltouMemoria;
	   }

	   pGrafo->pListaVertices = LIS_CriarLista( NULL ) ;
	   if (pGrafo->pListaVertices == NULL){
		   LIS_DestruirLista(pGrafo->pListaOrigens);
		   free(pGrafo);
		   return GRA_CondRetFaltouMemoria;
	   }

	   pGrafo->ExcluirValor = ExcluirValor;

	   *ppGrafo = pGrafo;

	   return GRA_CondRetOK;
   };


/***********************************************************************
*
*  $FC Função: GRA Destruir grafo
*
***********************************************************************/

   GRA_tpCondRet GRA_DestruirGrafo( GRA_tppGrafo pGrafo ) {
	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }
	   
	   GRA_EsvaziarGrafo(pGrafo);
	   LIS_DestruirLista(pGrafo->pListaOrigens);
	   LIS_DestruirLista(pGrafo->pListaVertices);
	   free(pGrafo);

	   return GRA_CondRetOK;
   }


/***********************************************************************
*
*  $FC Função: GRA Esvaziar
*
***********************************************************************/

   GRA_tpCondRet GRA_EsvaziarGrafo( GRA_tppGrafo pGrafo ) {

	   //ToDo
	   LIS_IrInicioLista( pGrafo->pListaVertices );
	   while (LIS_ObterValor( pGrafo->pListaVertices ) ) {
	   	RemoverVertice( (tppVerticeGrafo) LIS_ObterValor( pGrafo->pListaVertices ) );
	   	LIS_AvancarElementoCorrente(pGrafo->pListaVertices, 1);
	   }
	   LIS_EsvaziarLista( pGrafo->pListaVertices );
	   LIS_EsvaziarLista( pGrafo->pListaOrigens );
	   pGrafo->pVerticeCorrente = NULL;

	   return GRA_CondRetOK;
   }

   
/***********************************************************************
*
*  $FC Função: GRA Obter valor do vértice corrente
*
***********************************************************************/

	GRA_tpCondRet GRA_ObterValorCorrente( GRA_tppGrafo pGrafo, void ** ppValor ) {

	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   if (pGrafo->pVerticeCorrente == NULL){
		   return GRA_CondRetGrafoVazio;
	   }
	   
	   *ppValor = pGrafo->pVerticeCorrente->pValor;
	   	   
	   return GRA_CondRetOK;
   }

   
/***********************************************************************
*
*  $FC Função: GRA Alterar valor do vértice corrente
*
***********************************************************************/

   GRA_tpCondRet GRA_AlterarValorCorrente( GRA_tppGrafo pGrafo, void * pValor ) {

	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   if (pGrafo->pVerticeCorrente == NULL){
		   return GRA_CondRetGrafoVazio;
	   }

	   pGrafo->pVerticeCorrente->pValor = pValor;

	   return GRA_CondRetOK;
   }


/***********************************************************************
*
*  $FC Função: GRA Ir para vertice
*
***********************************************************************/

   GRA_tpCondRet GRA_IrParaVertice( GRA_tppGrafo pGrafo, char idVertice ) {
	   tppVerticeGrafo resultado;
	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   if (pGrafo->pVerticeCorrente == NULL){
		   return GRA_CondRetGrafoVazio;
	   }
		
	   resultado = PesquisaVertice( pGrafo->pListaVertices, idVertice );
	   if(resultado == NULL) {
		   return GRA_CondRetVerticeInvalido;
	   }

	   pGrafo->pVerticeCorrente = resultado;
	   
	   return GRA_CondRetOK;
   }


/***********************************************************************
*
*  $FC Função: GRA Andar para vertice
*
***********************************************************************/

   GRA_tpCondRet GRA_AndarParaVertice( GRA_tppGrafo pGrafo, char idVertice ) {
	   tppVerticeGrafo resultado;
	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   if (pGrafo->pVerticeCorrente == NULL){
		   return GRA_CondRetGrafoVazio;
	   }
	   
	   resultado = PesquisaVertice( pGrafo->pVerticeCorrente->pListaSuc, idVertice );
	   if(resultado == NULL) {
		   return GRA_CondRetVerticeInvalido;
	   }

	   pGrafo->pVerticeCorrente = resultado;

	   return GRA_CondRetOK;
   }

   
/***********************************************************************
*
*  $FC Função: GRA Inserir vértice
*
***********************************************************************/

   GRA_tpCondRet GRA_InserirVertice( GRA_tppGrafo pGrafo, void * pVertice, char idVertice ) {
	   tppVerticeGrafo vertice;
	   
	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   vertice = CriarVerticeGrafo();
	   if(vertice == NULL) {
		   return GRA_CondRetFaltouMemoria;
	   }

	   vertice->pValor = pVertice;
	   vertice->id = idVertice;

	   AdicionarVertice(pGrafo, vertice);
	   
	   return GRA_CondRetOK;
   }

   
/***********************************************************************
*
*  $FC Função: GRA Excluir vértice corrente
*
***********************************************************************/

   GRA_tpCondRet GRA_ExcluirVerticeCorrente( GRA_tppGrafo pGrafo ) {
	   LIS_tpCondRet condRetLis;

	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   RemoverVertice(pGrafo->pVerticeCorrente);
	   LIS_ProcurarValor(pGrafo->pListaVertices, (void *) pGrafo->pVerticeCorrente);
	   LIS_ExcluirElemento(pGrafo->pListaVertices);

	   condRetLis = LIS_ProcurarValor(pGrafo->pListaOrigens, (void *) pGrafo->pVerticeCorrente);
	   if(condRetLis == LIS_CondRetOK) {
		   LIS_ExcluirElemento(pGrafo->pListaOrigens);
	   }

	   // Reinicia corrente para o primeiro elemento da lista de vértices
	   LIS_IrInicioLista(pGrafo->pListaVertices);
	   pGrafo->pVerticeCorrente = (tppVerticeGrafo)LIS_ObterValor(pGrafo->pListaVertices);
	   
	   return GRA_CondRetOK;
   }

   
/***********************************************************************
*
*  $FC Função: GRA Inserir aresta
*
***********************************************************************/

   GRA_tpCondRet GRA_InserirAresta( GRA_tppGrafo pGrafo, char idVerticeOrigem, char idVerticeDestino, char * idAresta ) {
	   tppVerticeGrafo pVerticeOrigem, pVerticeDestino;
	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   if (pGrafo->pVerticeCorrente == NULL){
		   return GRA_CondRetGrafoVazio;
	   }

	   pVerticeOrigem = PesquisaVertice(pGrafo->pListaVertices, idVerticeOrigem);
	   if(pVerticeOrigem == NULL) {
		   return GRA_CondRetVerticeInvalido;
	   }
	   if(PesquisaVerticeNaListaDeAresta(pVerticeOrigem->pListaSuc, idVerticeDestino) != NULL) {
		   return GRA_CondRetArestaJaExiste;
	   }

	   pVerticeDestino = PesquisaVertice(pGrafo->pListaVertices, idVerticeDestino);
	   if(pVerticeDestino == NULL) {
		   return GRA_CondRetVerticeInvalido;
	   }

	   return AdicionarAresta(pGrafo,pVerticeOrigem,pVerticeDestino,idAresta);
   }

/***********************************************************************
*
*  $FC Função: GRA Inserir aresta no corrente
*
***********************************************************************/

   GRA_tpCondRet GRA_InserirArestaOrigemCorrente( GRA_tppGrafo pGrafo, char idVerticeDestino, char * idAresta ) {
	   tppVerticeGrafo pVerticeDestino;
	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   if (pGrafo->pVerticeCorrente == NULL){
		   return GRA_CondRetGrafoVazio;
	   }

	   if(PesquisaVerticeNaListaDeAresta(pGrafo->pVerticeCorrente->pListaSuc, idVerticeDestino) != NULL) {
		   return GRA_CondRetArestaJaExiste;
	   }

	   pVerticeDestino = PesquisaVertice(pGrafo->pListaVertices, idVerticeDestino);
	   if(pVerticeDestino == NULL) {
		   return GRA_CondRetVerticeInvalido;
	   }

	   return AdicionarAresta(pGrafo,pGrafo->pVerticeCorrente,pVerticeDestino,idAresta);
   }
   

/***********************************************************************
*
*  $FC Função: GRA Excluir aresta
*
***********************************************************************/

   GRA_tpCondRet GRA_ExcluirAresta( GRA_tppGrafo pGrafo, char * idAresta ) {
	   tppVerticeGrafo pVertice, pVerticeDestino;
	   GRA_tpAresta * pAresta;
	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   // Busca idAresta em 
	   while (LIS_ObterValor( pGrafo->pListaVertices ) ) {
			pVertice = (tppVerticeGrafo) LIS_ObterValor( pGrafo->pListaVertices );

			while (LIS_ObterValor( pVertice->pListaSuc ) ) {
				pAresta = (GRA_tpAresta *) LIS_ObterValor( pVertice->pListaSuc );

				if(strcmp(idAresta, pAresta->idAresta) == 0) {
					pVerticeDestino = pAresta->pVerticeApontado;

					LIS_ExcluirElemento( pVertice->pListaSuc );

					LIS_ProcurarValor( pVerticeDestino->pListaAnt, pVertice);
					LIS_ExcluirElemento( pVerticeDestino->pListaAnt );
					return GRA_CondRetOK;
				}

				LIS_AvancarElementoCorrente(pVertice->pListaSuc, 1);
			}

	   		LIS_AvancarElementoCorrente(pGrafo->pListaVertices, 1);
	   }
	   
	   return GRA_CondRetArestaInvalida;
   }


/***********************************************************************
*
*  $FC Função: GRA Adicionar origem
*
***********************************************************************/

   GRA_tpCondRet GRA_AdicionarOrigem( GRA_tppGrafo pGrafo, char idVertice ) {
	   tppVerticeGrafo pVertice;
	   LIS_tpCondRet condRetLis;
	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   pVertice = PesquisaVertice(pGrafo->pListaVertices, idVertice);
	   if(pVertice == NULL) {
		   return GRA_CondRetVerticeInvalido;
	   }

	   LIS_IrFinalLista(pGrafo->pListaOrigens);
	   condRetLis = LIS_InserirElementoApos(pGrafo->pListaOrigens, (void *) pVertice);
	   if(condRetLis == LIS_CondRetFaltouMemoria) {
	   		return GRA_CondRetFaltouMemoria;
	   }

	   return GRA_CondRetOK;

   }


/***********************************************************************
*
*  $FC Função: GRA Remover origem
*
***********************************************************************/

   GRA_tpCondRet GRA_RemoverOrigem( GRA_tppGrafo pGrafo, char idVertice ) {
	   tppVerticeGrafo pVertice;
	   if (pGrafo == NULL){
		   return GRA_CondRetPonteiroNulo;
	   }

	   pVertice = PesquisaVertice(pGrafo->pListaOrigens, idVertice);
	   if(pVertice == NULL) {
		   return GRA_CondRetVerticeInvalido;
	   }

	   LIS_ExcluirElemento( pGrafo->pListaOrigens );

	   return GRA_CondRetOK;
   }






/********** Fim do módulo de implementação: Módulo grafo dirigido **********/
